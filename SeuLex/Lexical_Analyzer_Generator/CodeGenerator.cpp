#include "stdafx.h"

string IntToStr(int i)
{
	string ss;
	char buf[10];
	sprintf(buf, "%d",i);
	ss=buf;
	return ss;
}

CodeGenerator::CodeGenerator(void)
{
	program_file_type=".cmm";
	token_file_type=".seq";//输出的source code输出的文件类型
					//token 序列

	source_file_name="lexical_analyzer.cpp";


	s1="/*\n*Lexical_Analyzer\n*Generated by Lexical_Analyzer_Generator.exe\n*author:ShrekShao_61311115\n*/\n\n";

	s1+="#include<iostream>\n";
	s1+="#include<fstream>\n";
	s1+="#include<string>\n";
	s1+="#include<assert.h>\n";
	s1+="#include<vector>\n";
	s1+="using namespace std;\n";






	s2="int main()\n{\n";
	s2+="int i;\n";
	//变量存储vector
	//要快的话可以用hash
	//以输出内码(vector 内的下标）
	//内码变量表的数目=变量类型token的数目
	




	s2+="string program_type=\""+program_file_type+"\";\n";
	s2+="ifstream in;\n";
	s2+="in.open(\"source_code\"+program_type,ios::binary);\n";
	s2+="assert(!in.fail());\n";

	//out.open 和state赋初值都要在后头补
	//def


	s3="int state=start_state;\nchar c;\nbool jumpout;\nbool input_end=false;\nstring value;\n";

	s4="while(!input_end)\n{\n";
	s4+="in.read(&c,1);\n";			//12-9修改
	s4+="if(in.eof())\n{\n";
	s4+="input_end=true;\n";
	s4+="c=\'\\0\';\n";
	s4+="}\n";
	
	s4+="do\n{\n";
	s4+="jumpout=false;\n";


	s5="switch(state)\n{\n";



	
	e1="}\n";	//switch的后大括号
	e1+="value+=c;\njumpout=true;\n}while(!jumpout && !input_end);\n";

	e2="}\n";	//while的后大括号
	e2+="out<<\"$ $ $\\n\";\n";


	e3="in.close();\nout.close();\nreturn 0;\n}\n";
}


CodeGenerator::~CodeGenerator(void)
{
}



CodeGenerator* CodeGenerator::Instance()
{
	static CodeGenerator instance;
	return &instance;
}


string CodeGenerator::GetProgramFileType()
{
	return program_file_type;
}


void CodeGenerator::SetFileName(const string& n)
{
	source_file_name=n+".cpp";
}
void CodeGenerator::SetTokenFileType(const string& n)
{
	token_file_type="."+n;
}
void CodeGenerator::SetProgramFileType(const string& n)
{
	program_file_type="."+n;
}

void CodeGenerator::GenerateSourceCode(FiniteAutomata & dfa)
{
	//12-8 不行啊，必须让LA能读到' ','\t','\n'
	//12-9使用binary方式解决该问题
	//12-9加入可归约为token但不输出为token的空白VN



	//token的存储单元？就是最原始string 输出<tkn_name, value>?

	//string sc;	//source code

	cout<<"生成词法分析器"<<source_file_name<<"..\n\n";



	int i;
	for(i=0;i<pVNManager->GetVarTokenNum();i++)
	{
		s2+="vector<string> var"+IntToStr(i)+";\n";
	}




	ofstream out;
	out.open(source_file_name);
	//..solution 1: while-switch-if...
	out<<s1;
	out<<s2;

	//构建def:string
	//TODO:state赋初值，o.open文件名
	string ss;		//转化成string的start_state idx

	{
		char buf[10];
		sprintf(buf, "%d",dfa.GetStartNode());
		ss=buf;
	}

	/////////////////////////////

	def="\nint start_state="+ss+";\n";
	def+="ofstream out;\n";
	def+="out.open(\"token_sequence"+token_file_type+"\");\n";
	/*
	int start_state=0;		//from dfa 生成时搞好

	ofstream out;
	out.open("token_sequence.txt");
	*/
	//////////////////////

	out<<def;

	out<<s3;
	out<<s4;
	out<<s5;



	////////////////////////////
	//for switch-if

	FiniteAutomata::NodeIterator ni(dfa);

	//int tmp_accept;
	FA_GraphNode* pnode=NULL;
	FA_GraphEdge* pedge=NULL;

	//string tmp_out;
	pnode=ni.begin();

	while(pnode!=NULL)
	{
		//for each state node
		{
			ss.clear();
			char buf[10];
			sprintf(buf, "%d",pnode->Index());
			ss=buf;
		}

		



		//case ss
		out<<"case "<<ss<<":\n";

		FiniteAutomata::EdgeIterator ei(dfa,pnode->Index());

		//12-8 没有边的节点的情况的处理
		if(dfa.GetEdgeNumOfNode(pnode->Index())>0)
		{
			pedge=ei.begin();
		}
		else
		{
			//当前节点没有伸出边

			if(pnode->GetAcceptingNode()==NON_ACCEPTING)
			{
				//非结束节点
				out<<"assert(\"invalid input char\" && 0);\n";
			}
			else if(pnode->GetAcceptingNode()==DEFAULT_END)
			{
				//空白符
				out<<"assert(value.size() && \"invalid input char\");\n";		//?12-11 epsilon的死循环
				out<<"value.clear();\n";
				out<<"state=start_state;\n";
				out<<"continue;\n";
			}
			else
			{
				//结束节点 accepting node

				
				//2014-5-6
				//TODO:输出token的格式做成 名称,类码，内码
				//出现过的变量由一组内建vector<string>var[&]存储着，管理内码，理解为变量的地址
				int token_id=pnode->GetAcceptingNode();	//类型码


				if(pVNManager->GetVNAt(token_id).addressvn)
				{
					//有内码

					int address_vec_id=pVNManager->GetVNAt(token_id).address_token_id;
					//int i;


					out<<"for(i=0;i<var"<<address_vec_id<<".size();i++)\n{\n";
					out<<"if(var"<<address_vec_id<<".at(i)==value){break;}\n";
					out<<"}\n";


					//新变量
					out<<"if(i==var"<<address_vec_id<<".size())\n";
					out<<"{\nvar"<<address_vec_id<<".push_back(value);\n}\n";

					//此时i就为内码

					// token名称，token类型码，内码
					out<<"out<<value<<' '<<"<<token_id<<"<<' '<<i<<'\\n';\n";
				}
				else
				{
					out<<"out<<value<<' '<<"<<token_id<<"<<'\\n';\n";
				}
				
				//out<<"out<<\""<<pVNManager->GetTokenNameAt(pnode->GetAcceptingNode())<<"\"<<'\\t'<<'\\t'<<value<<'\\n';\n";
				out<<"value.clear();\n";
				out<<"state=start_state;\n";
				out<<"continue;\n";
			}
			out<<"break;\n";
			pnode=ni.next();
			continue;
		}

		






		int isbegin=true;
		while(pedge!=NULL)
		{
			if(isbegin)
			{
				//第一条边,if
				isbegin=false;
				out<<"if";
			}
			else
			{
				//else if
				out<<"else if";
			}

			


			
			

			//这里==char要改成c==int,不然\t,\n之类转义字符没法表示
			{
				ss.clear();
				char buf[5];
				sprintf(buf, "%d",(int)pedge->getVT());
				ss=buf;
			}


			out<<"(c=="<<ss<<")";



			{
				ss.clear();
				char buf[10];
				sprintf(buf, "%d",pedge->To());
				ss=buf;
			}
			out<<"{state="<<ss<<";}\n";


			pedge=ei.next();
		}


		out<<"else\n{\n";

		if(pnode->GetAcceptingNode()==NON_ACCEPTING)
		{
			//非结束节点
			out<<"assert(\"invalid input char\" && 0);\n";
		}
		else if(pnode->GetAcceptingNode()==DEFAULT_END)
		{
			//空白符
			out<<"assert(value.size() && \"invalid input char\");\n";		//?12-11 epsilon的死循环
			out<<"value.clear();\n";
			out<<"state=start_state;\n";
			out<<"continue;\n";
		}
		else
		{
			//结束节点 accepting node

			//2014-5-6
			//TODO:输出token的格式做成 名称,类码，内码
			//出现过的变量由内建vector<string>var&存储着，管理内码，理解为变量的地址
			int token_id=pnode->GetAcceptingNode();	//类型码


			if(pVNManager->GetVNAt(token_id).addressvn)
			{
				//有内码

				int address_vec_id=pVNManager->GetVNAt(token_id).address_token_id;
				//int i;


				out<<"for(i=0;i<var"<<address_vec_id<<".size();i++)\n{\n";
				out<<"if(var"<<address_vec_id<<".at(i)==value){break;}\n";
				out<<"}\n";


				//新变量
				out<<"if(i==var"<<address_vec_id<<".size())\n";
				out<<"{\nvar"<<address_vec_id<<".push_back(value);\n}\n";

				//此时i就为内码

				// token名称，token类型码，内码
				out<<"out<<value<<' '<<"<<token_id<<"<<' '<<i<<'\\n';\n";
			}
			else
			{
				out<<"out<<value<<' '<<"<<token_id<<"<<'\\n';\n";
			}

			//out<<"out<<\""<<pVNManager->GetTokenNameAt(pnode->GetAcceptingNode())<<"\"<<'\\t'<<'\\t'<<value<<'\\n';\n";
			out<<"value.clear();\n";
			out<<"state=start_state;\n";
			out<<"continue;\n";
		}


		out<<"}\n";
		out<<"break;\n";
		pnode=ni.next();
	}

	//..........................
	out<<"default:assert(\"invalid input char!\" &&0);\n";

	out<<e1;
	out<<e2;
	out<<e3;

	out.close();

}